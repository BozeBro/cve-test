#include "nuraft.hxx"
#include "in_memory_state_mgr.hxx"
#include "in_memory_log_store.hxx"
#include "echo_state_machine.hxx"
#include "help.hxx"

#include "logger_wrapper.hxx"
#include <iostream>
#include <string>
#include <vector>
#include <chrono>
#include <thread>
#include <atomic>
#include <csignal>

using namespace nuraft;

int main() {
    std::cout << "Starting Raft Test\n";
    int srv_size = 3;
    std::vector<test_launcher> launchers(srv_size);
    std::vector<ptr<raft_server>> servers(srv_size);
    // Initialize each server.
    for (int i = 1; i <= srv_size; i++) {
        test_launcher launcher;
        std::string log_file = "/data/srv" + std::to_string(i) + ".log";
        ptr<my_logger> my_wrapper = cs_new<my_logger>( log_file, 4 );
        ptr<logger> my_logger = my_wrapper;
        int base_port = 5000;
        int my_port   = base_port + i;
        ptr<state_mgr> my_state_mgr = cs_new<inmem_state_mgr>(i, "localhost:" + std::to_string(my_port));
        ptr<state_machine> my_state_machine = cs_new<echo_state_machine>();
        asio_service::options asio_opt;
        raft_params params;
        // Using params from here https://github.com/eBay/NuRaft/issues/207
        params.heart_beat_interval_ = 500; 
        params.election_timeout_lower_bound_ = 1000; 
        params.election_timeout_upper_bound_ = 2000; 
        params.reserved_log_items_ = 10000000; 
        params.snapshot_distance_ = 100000; 
        params.client_req_timeout_ = 4000; 
        params.return_method_ = raft_params::blocking; 
        
        if (i == 2) {
            params.election_timeout_lower_bound_ = -1;
        }

        ptr<raft_server> server = launcher.init(
            my_state_machine,
            my_state_mgr,
            my_logger,
            my_port,
            asio_opt,
            params,
            raft_server::init_options(),
            i == 2
        );

        while (!server->is_initialized()) {
            std::this_thread::sleep_for( std::chrono::milliseconds(100) );
        }
        std::cout << "Server " << i << " has been initialized\n";
        launchers[i-1] = launcher;
        servers[i-1] = server;
    }
    for (size_t i = 1; i < srv_size; i++) {
        ptr<raft_server> leader = servers[0];
        ptr<raft_server> member = servers[i];
        ptr<srv_config> cfg = member->get_srv_config(i+1);
        ptr<cmd_result< ptr<buffer> >> ret = leader->add_srv(*cfg);
        if (!ret->get_accepted()) {
            std::cout << "FAILED to add server " << (i+1) << '\n';
            return -1;
        }
        // Wait until it appears in server list.
        const size_t MAX_TRY = 40;
        for (size_t jj=0; jj<MAX_TRY; ++jj) {
            std::this_thread::sleep_for(std::chrono::milliseconds(250));
            ptr<srv_config> conf =
                leader->get_srv_config(i+1);
            if (conf) {
                std::cout << "server " << (i+1) << " successfully added\n";
                break;
            }
        }
    }

    static std::atomic<bool>running(true);
    // Wait for CTRL+C etc
    std::signal(SIGINT, [](int /* sig */) {
        running = false;
    });
    while(running) {
        static constexpr auto running_check_delay
            = std::chrono::milliseconds(1000);
        std::this_thread::sleep_for(running_check_delay);
        bool check = true;
        for (auto srv : servers) {
            ulong two = 2;
            if (srv->get_term() < two) check = false;
        }
        if (check) {
            auto srv = servers[0];
            // The leader should be the same for all servers.
            std::cout << "The leader for all servers for term 2 is " << srv->get_leader() << '\n';
            break;
        }
    }
    for (auto launcher : launchers) {
            launcher.shutdown();
    }
    return 0; 
}