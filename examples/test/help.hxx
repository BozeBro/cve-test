
#include "nuraft.hxx"
#include "logger_wrapper.hxx"
#include <string>
#include <iostream>
using namespace nuraft;

class byzantine_server : public raft_server {
    public:
        using raft_server::raft_server;
        ptr<resp_msg> process_req(req_msg& req) {
            ptr<resp_msg> resp = raft_server::process_req(req);
            // We assume server can timeout at anytime. Therefore, We can timeout anytime 
            if (!is_leader() && req.get_src() == get_leader()) handle_election_timeout();
            return resp;
        }
};

class test_launcher : public raft_launcher {
    public:
        using raft_launcher::raft_launcher;
        ptr<raft_server> init(ptr<state_machine> sm,
                                     ptr<state_mgr> smgr,
                                     ptr<logger> lg,
                                     int port_number,
                                     const asio_service::options& asio_options,
                                     const raft_params& params_given,
                                     const raft_server::init_options& opt,
                                     bool byzantine=false)
        {
            asio_svc_ = cs_new<asio_service>(asio_options, lg);
            asio_listener_ = asio_svc_->create_rpc_listener(port_number, lg);
            if (!asio_listener_) return nullptr;
            ptr<delayed_task_scheduler> scheduler = asio_svc_;
            ptr<rpc_client_factory> rpc_cli_factory = asio_svc_;
            context* ctx = new context( smgr,
                                        sm,
                                        asio_listener_,
                                        lg,
                                        rpc_cli_factory,
                                        scheduler,
                                        params_given );
            // The one changed line
            raft_instance_ = byzantine ? cs_new<byzantine_server>(ctx, opt) : cs_new<raft_server>(ctx, opt);
            asio_listener_->listen( raft_instance_ );
            return raft_instance_;
        }
    private:
        ptr<asio_service> asio_svc_;
        ptr<rpc_listener> asio_listener_;
        ptr<raft_server> raft_instance_;
};

class my_logger : public logger_wrapper {
    public:
        using logger_wrapper::logger_wrapper;
        void put_details(int level,
                     const char* source_file,
                     const char* func_name,
                     size_t line_number,
                     const std::string& msg)
    {
        logger_wrapper::put_details(level, source_file, func_name, line_number, msg);
        // Print only lines that contain the leader a server sees.
        if (msg.find("leader: ") != std::string::npos && msg.find("peer 3") != std::string::npos) {
            std::cout << msg << '\n' << '\n';
        }
    }
};